{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule, Optional, SkipSelf } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { map, mergeMap } from 'rxjs/operators';\nimport { defer, of } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nconst JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\n\n/* eslint-disable no-bitwise */\nlet JwtHelperService = /*#__PURE__*/(() => {\n  class JwtHelperService {\n    constructor(config = null) {\n      this.tokenGetter = config && config.tokenGetter || function () {};\n    }\n    urlBase64Decode(str) {\n      let output = str.replace(/-/g, '+').replace(/_/g, '/');\n      switch (output.length % 4) {\n        case 0:\n          {\n            break;\n          }\n        case 2:\n          {\n            output += '==';\n            break;\n          }\n        case 3:\n          {\n            output += '=';\n            break;\n          }\n        default:\n          {\n            throw new Error('Illegal base64url string!');\n          }\n      }\n      return this.b64DecodeUnicode(output);\n    }\n    // credits for decoder goes to https://github.com/atk\n    b64decode(str) {\n      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n      let output = '';\n      str = String(str).replace(/=+$/, '');\n      if (str.length % 4 === 1) {\n        throw new Error(`'atob' failed: The string to be decoded is not correctly encoded.`);\n      }\n      for (\n      // initialize result and counters\n      let bc = 0, bs, buffer, idx = 0;\n      // get next character\n      buffer = str.charAt(idx++);\n      // character found in table? initialize bit storage and add its ascii value;\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n      // and if not first of each 4 characters,\n      // convert the first 8 bits to one ascii character\n      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n        // try to find character in table (0-63, not found => -1)\n        buffer = chars.indexOf(buffer);\n      }\n      return output;\n    }\n    b64DecodeUnicode(str) {\n      return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), c => {\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(''));\n    }\n    decodeToken(token = this.tokenGetter()) {\n      if (token instanceof Promise) {\n        return token.then(t => this._decodeToken(t));\n      }\n      return this._decodeToken(token);\n    }\n    _decodeToken(token) {\n      if (!token || token === '') {\n        return null;\n      }\n      const parts = token.split('.');\n      if (parts.length !== 3) {\n        throw new Error(`The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.`);\n      }\n      const decoded = this.urlBase64Decode(parts[1]);\n      if (!decoded) {\n        throw new Error('Cannot decode the token.');\n      }\n      return JSON.parse(decoded);\n    }\n    getTokenExpirationDate(token = this.tokenGetter()) {\n      if (token instanceof Promise) {\n        return token.then(t => this._getTokenExpirationDate(t));\n      }\n      return this._getTokenExpirationDate(token);\n    }\n    _getTokenExpirationDate(token) {\n      let decoded;\n      decoded = this.decodeToken(token);\n      if (!decoded || !decoded.hasOwnProperty('exp')) {\n        return null;\n      }\n      const date = new Date(0);\n      date.setUTCSeconds(decoded.exp);\n      return date;\n    }\n    isTokenExpired(token = this.tokenGetter(), offsetSeconds) {\n      if (token instanceof Promise) {\n        return token.then(t => this._isTokenExpired(t, offsetSeconds));\n      }\n      return this._isTokenExpired(token, offsetSeconds);\n    }\n    _isTokenExpired(token, offsetSeconds) {\n      if (!token || token === '') {\n        return true;\n      }\n      const date = this.getTokenExpirationDate(token);\n      offsetSeconds = offsetSeconds || 0;\n      if (date === null) {\n        return false;\n      }\n      return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    }\n    getAuthScheme(authScheme, request) {\n      if (typeof authScheme === 'function') {\n        return authScheme(request);\n      }\n      return authScheme;\n    }\n  }\n  JwtHelperService.ɵfac = function JwtHelperService_Factory(t) {\n    return new (t || JwtHelperService)(i0.ɵɵinject(JWT_OPTIONS));\n  };\n  JwtHelperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: JwtHelperService,\n    factory: JwtHelperService.ɵfac\n  });\n  return JwtHelperService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst fromPromiseOrValue = input => {\n  if (input instanceof Promise) {\n    return defer(() => input);\n  }\n  return of(input);\n};\nlet JwtInterceptor = /*#__PURE__*/(() => {\n  class JwtInterceptor {\n    constructor(config, jwtHelper, document) {\n      this.jwtHelper = jwtHelper;\n      this.document = document;\n      this.standardPorts = ['80', '443'];\n      this.tokenGetter = config.tokenGetter;\n      this.headerName = config.headerName || 'Authorization';\n      this.authScheme = config.authScheme || config.authScheme === '' ? config.authScheme : 'Bearer ';\n      this.allowedDomains = config.allowedDomains || [];\n      this.disallowedRoutes = config.disallowedRoutes || [];\n      this.throwNoTokenError = config.throwNoTokenError || false;\n      this.skipWhenExpired = config.skipWhenExpired;\n    }\n    isAllowedDomain(request) {\n      const requestUrl = new URL(request.url, this.document.location.origin);\n      // If the host equals the current window origin,\n      // the domain is allowed by default\n      if (requestUrl.host === this.document.location.host) {\n        return true;\n      }\n      // If not the current domain, check the allowed list\n      const hostName = `${requestUrl.hostname}${requestUrl.port && !this.standardPorts.includes(requestUrl.port) ? ':' + requestUrl.port : ''}`;\n      return this.allowedDomains.findIndex(domain => typeof domain === 'string' ? domain === hostName : domain instanceof RegExp ? domain.test(hostName) : false) > -1;\n    }\n    isDisallowedRoute(request) {\n      const requestedUrl = new URL(request.url, this.document.location.origin);\n      return this.disallowedRoutes.findIndex(route => {\n        if (typeof route === 'string') {\n          const parsedRoute = new URL(route, this.document.location.origin);\n          return parsedRoute.hostname === requestedUrl.hostname && parsedRoute.pathname === requestedUrl.pathname;\n        }\n        if (route instanceof RegExp) {\n          return route.test(request.url);\n        }\n        return false;\n      }) > -1;\n    }\n    handleInterception(token, request, next) {\n      const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n      if (!token && this.throwNoTokenError) {\n        throw new Error('Could not get token from tokenGetter function.');\n      }\n      let tokenIsExpired = of(false);\n      if (this.skipWhenExpired) {\n        tokenIsExpired = token ? fromPromiseOrValue(this.jwtHelper.isTokenExpired(token)) : of(true);\n      }\n      if (token) {\n        return tokenIsExpired.pipe(map(isExpired => isExpired && this.skipWhenExpired ? request.clone() : request.clone({\n          setHeaders: {\n            [this.headerName]: `${authScheme}${token}`\n          }\n        })), mergeMap(innerRequest => next.handle(innerRequest)));\n      }\n      return next.handle(request);\n    }\n    intercept(request, next) {\n      if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n        return next.handle(request);\n      }\n      const token = this.tokenGetter(request);\n      return fromPromiseOrValue(token).pipe(mergeMap(asyncToken => {\n        return this.handleInterception(asyncToken, request, next);\n      }));\n    }\n  }\n  JwtInterceptor.ɵfac = function JwtInterceptor_Factory(t) {\n    return new (t || JwtInterceptor)(i0.ɵɵinject(JWT_OPTIONS), i0.ɵɵinject(JwtHelperService), i0.ɵɵinject(DOCUMENT));\n  };\n  JwtInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: JwtInterceptor,\n    factory: JwtInterceptor.ɵfac\n  });\n  return JwtInterceptor;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet JwtModule = /*#__PURE__*/(() => {\n  class JwtModule {\n    constructor(parentModule) {\n      if (parentModule) {\n        throw new Error(`JwtModule is already loaded. It should only be imported in your application's main module.`);\n      }\n    }\n    static forRoot(options) {\n      return {\n        ngModule: JwtModule,\n        providers: [{\n          provide: HTTP_INTERCEPTORS,\n          useClass: JwtInterceptor,\n          multi: true\n        }, options.jwtOptionsProvider || {\n          provide: JWT_OPTIONS,\n          useValue: options.config\n        }, JwtHelperService]\n      };\n    }\n  }\n  JwtModule.ɵfac = function JwtModule_Factory(t) {\n    return new (t || JwtModule)(i0.ɵɵinject(JwtModule, 12));\n  };\n  JwtModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: JwtModule\n  });\n  JwtModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return JwtModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule };","map":{"version":3,"names":["i0","InjectionToken","Injectable","Inject","NgModule","Optional","SkipSelf","DOCUMENT","map","mergeMap","defer","of","HTTP_INTERCEPTORS","JWT_OPTIONS","JwtHelperService","constructor","config","tokenGetter","urlBase64Decode","str","output","replace","length","Error","b64DecodeUnicode","b64decode","chars","String","bc","bs","buffer","idx","charAt","fromCharCode","indexOf","decodeURIComponent","Array","prototype","call","c","charCodeAt","toString","slice","join","decodeToken","token","Promise","then","t","_decodeToken","parts","split","decoded","JSON","parse","getTokenExpirationDate","_getTokenExpirationDate","hasOwnProperty","date","Date","setUTCSeconds","exp","isTokenExpired","offsetSeconds","_isTokenExpired","valueOf","getAuthScheme","authScheme","request","ɵfac","JwtHelperService_Factory","ɵɵinject","ɵprov","ɵɵdefineInjectable","factory","ngDevMode","fromPromiseOrValue","input","JwtInterceptor","jwtHelper","document","standardPorts","headerName","allowedDomains","disallowedRoutes","throwNoTokenError","skipWhenExpired","isAllowedDomain","requestUrl","URL","url","location","origin","host","hostName","hostname","port","includes","findIndex","domain","RegExp","test","isDisallowedRoute","requestedUrl","route","parsedRoute","pathname","handleInterception","next","tokenIsExpired","pipe","isExpired","clone","setHeaders","innerRequest","handle","intercept","asyncToken","JwtInterceptor_Factory","JwtModule","parentModule","forRoot","options","ngModule","providers","provide","useClass","multi","jwtOptionsProvider","useValue","JwtModule_Factory","ɵmod","ɵɵdefineNgModule","type","ɵinj","ɵɵdefineInjector"],"sources":["D:/my projects/RBAC/rbac-client/node_modules/@auth0/angular-jwt/fesm2020/auth0-angular-jwt.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule, Optional, SkipSelf } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { map, mergeMap } from 'rxjs/operators';\nimport { defer, of } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\n\nconst JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\n\n/* eslint-disable no-bitwise */\nclass JwtHelperService {\n    constructor(config = null) {\n        this.tokenGetter = (config && config.tokenGetter) || function () { };\n    }\n    urlBase64Decode(str) {\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\n        switch (output.length % 4) {\n            case 0: {\n                break;\n            }\n            case 2: {\n                output += '==';\n                break;\n            }\n            case 3: {\n                output += '=';\n                break;\n            }\n            default: {\n                throw new Error('Illegal base64url string!');\n            }\n        }\n        return this.b64DecodeUnicode(output);\n    }\n    // credits for decoder goes to https://github.com/atk\n    b64decode(str) {\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        let output = '';\n        str = String(str).replace(/=+$/, '');\n        if (str.length % 4 === 1) {\n            throw new Error(`'atob' failed: The string to be decoded is not correctly encoded.`);\n        }\n        for (\n        // initialize result and counters\n        let bc = 0, bs, buffer, idx = 0; \n        // get next character\n        (buffer = str.charAt(idx++)); \n        // character found in table? initialize bit storage and add its ascii value;\n        ~buffer &&\n            ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n                // and if not first of each 4 characters,\n                // convert the first 8 bits to one ascii character\n                bc++ % 4)\n            ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n            : 0) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n        return output;\n    }\n    b64DecodeUnicode(str) {\n        return decodeURIComponent(Array.prototype.map\n            .call(this.b64decode(str), (c) => {\n            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n            .join(''));\n    }\n    decodeToken(token = this.tokenGetter()) {\n        if (token instanceof Promise) {\n            return token.then(t => this._decodeToken(t));\n        }\n        return this._decodeToken(token);\n    }\n    _decodeToken(token) {\n        if (!token || token === '') {\n            return null;\n        }\n        const parts = token.split('.');\n        if (parts.length !== 3) {\n            throw new Error(`The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.`);\n        }\n        const decoded = this.urlBase64Decode(parts[1]);\n        if (!decoded) {\n            throw new Error('Cannot decode the token.');\n        }\n        return JSON.parse(decoded);\n    }\n    getTokenExpirationDate(token = this.tokenGetter()) {\n        if (token instanceof Promise) {\n            return token.then(t => this._getTokenExpirationDate(t));\n        }\n        return this._getTokenExpirationDate(token);\n    }\n    _getTokenExpirationDate(token) {\n        let decoded;\n        decoded = this.decodeToken(token);\n        if (!decoded || !decoded.hasOwnProperty('exp')) {\n            return null;\n        }\n        const date = new Date(0);\n        date.setUTCSeconds(decoded.exp);\n        return date;\n    }\n    isTokenExpired(token = this.tokenGetter(), offsetSeconds) {\n        if (token instanceof Promise) {\n            return token.then(t => this._isTokenExpired(t, offsetSeconds));\n        }\n        return this._isTokenExpired(token, offsetSeconds);\n    }\n    _isTokenExpired(token, offsetSeconds) {\n        if (!token || token === '') {\n            return true;\n        }\n        const date = this.getTokenExpirationDate(token);\n        offsetSeconds = offsetSeconds || 0;\n        if (date === null) {\n            return false;\n        }\n        return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    }\n    getAuthScheme(authScheme, request) {\n        if (typeof authScheme === 'function') {\n            return authScheme(request);\n        }\n        return authScheme;\n    }\n}\nJwtHelperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: JwtHelperService, deps: [{ token: JWT_OPTIONS }], target: i0.ɵɵFactoryTarget.Injectable });\nJwtHelperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: JwtHelperService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: JwtHelperService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [JWT_OPTIONS]\n                }] }]; } });\n\nconst fromPromiseOrValue = (input) => {\n    if (input instanceof Promise) {\n        return defer(() => input);\n    }\n    return of(input);\n};\nclass JwtInterceptor {\n    constructor(config, jwtHelper, document) {\n        this.jwtHelper = jwtHelper;\n        this.document = document;\n        this.standardPorts = ['80', '443'];\n        this.tokenGetter = config.tokenGetter;\n        this.headerName = config.headerName || 'Authorization';\n        this.authScheme =\n            config.authScheme || config.authScheme === ''\n                ? config.authScheme\n                : 'Bearer ';\n        this.allowedDomains = config.allowedDomains || [];\n        this.disallowedRoutes = config.disallowedRoutes || [];\n        this.throwNoTokenError = config.throwNoTokenError || false;\n        this.skipWhenExpired = config.skipWhenExpired;\n    }\n    isAllowedDomain(request) {\n        const requestUrl = new URL(request.url, this.document.location.origin);\n        // If the host equals the current window origin,\n        // the domain is allowed by default\n        if (requestUrl.host === this.document.location.host) {\n            return true;\n        }\n        // If not the current domain, check the allowed list\n        const hostName = `${requestUrl.hostname}${requestUrl.port && !this.standardPorts.includes(requestUrl.port)\n            ? ':' + requestUrl.port\n            : ''}`;\n        return (this.allowedDomains.findIndex((domain) => typeof domain === 'string'\n            ? domain === hostName\n            : domain instanceof RegExp\n                ? domain.test(hostName)\n                : false) > -1);\n    }\n    isDisallowedRoute(request) {\n        const requestedUrl = new URL(request.url, this.document.location.origin);\n        return (this.disallowedRoutes.findIndex((route) => {\n            if (typeof route === 'string') {\n                const parsedRoute = new URL(route, this.document.location.origin);\n                return (parsedRoute.hostname === requestedUrl.hostname &&\n                    parsedRoute.pathname === requestedUrl.pathname);\n            }\n            if (route instanceof RegExp) {\n                return route.test(request.url);\n            }\n            return false;\n        }) > -1);\n    }\n    handleInterception(token, request, next) {\n        const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n        if (!token && this.throwNoTokenError) {\n            throw new Error('Could not get token from tokenGetter function.');\n        }\n        let tokenIsExpired = of(false);\n        if (this.skipWhenExpired) {\n            tokenIsExpired = token ? fromPromiseOrValue(this.jwtHelper.isTokenExpired(token)) : of(true);\n        }\n        if (token) {\n            return tokenIsExpired.pipe(map((isExpired) => isExpired && this.skipWhenExpired\n                ? request.clone()\n                : request.clone({\n                    setHeaders: {\n                        [this.headerName]: `${authScheme}${token}`,\n                    },\n                })), mergeMap((innerRequest) => next.handle(innerRequest)));\n        }\n        return next.handle(request);\n    }\n    intercept(request, next) {\n        if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n            return next.handle(request);\n        }\n        const token = this.tokenGetter(request);\n        return fromPromiseOrValue(token).pipe(mergeMap((asyncToken) => {\n            return this.handleInterception(asyncToken, request, next);\n        }));\n    }\n}\nJwtInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: JwtInterceptor, deps: [{ token: JWT_OPTIONS }, { token: JwtHelperService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\nJwtInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: JwtInterceptor });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: JwtInterceptor, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [JWT_OPTIONS]\n                }] }, { type: JwtHelperService }, { type: Document, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }]; } });\n\nclass JwtModule {\n    constructor(parentModule) {\n        if (parentModule) {\n            throw new Error(`JwtModule is already loaded. It should only be imported in your application's main module.`);\n        }\n    }\n    static forRoot(options) {\n        return {\n            ngModule: JwtModule,\n            providers: [\n                {\n                    provide: HTTP_INTERCEPTORS,\n                    useClass: JwtInterceptor,\n                    multi: true,\n                },\n                options.jwtOptionsProvider || {\n                    provide: JWT_OPTIONS,\n                    useValue: options.config,\n                },\n                JwtHelperService,\n            ],\n        };\n    }\n}\nJwtModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: JwtModule, deps: [{ token: JwtModule, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.NgModule });\nJwtModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.3.0\", ngImport: i0, type: JwtModule });\nJwtModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: JwtModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: JwtModule, decorators: [{\n            type: NgModule\n        }], ctorParameters: function () { return [{ type: JwtModule, decorators: [{\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }]; } });\n\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}